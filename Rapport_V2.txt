1. Veuillez indiquer où se trouve dans votre projet un exemple de chacun des concepts suivants (en indiquant le concept, le nom du fichier et le numéro de ligne) :

a. Un exemple de masquage public:
Fichier : Transducer.h  ligne : 32

virtual std::string transduce(symbol_t symbol) = 0;

Cette fonction va être hérité par les enfants de Transducer. Ceux-ci sont obligé d'implémenter leur version de cette fonction.

b. Un exemple de masquage protégé:
Fichier : Reader.h ligne : 47

virtual symbol_t readOneFromSource() = 0;

Les enfants de Reader sont obligé d'implémenter leur version de cette fonction qu'ils héritent de leur parent.

c. Un exemple de masquage privé:
Fichier  : FST.h lignes : 43-44

virtual void initialize() {}
virtual void writeOptionInfo(Writer & writer) {}

Ces deux fonctions vont être héritées par les enfants de et ceux-ci vont devoir les implémenter eux-mêmes.

d. Un exemple de surcharge de fonction:
Fichier : TransducerCounter.h ligne : 35
std::string transduce(symbol_t symbol) override;

Fichier : TransducerRepeater.h ligne : 27
std::string transduce(symbol_t symbol) override; ///wtf je comprends pas pourquoi override serait une surcharge alors que c'est =. ???

Fichier : TransducerReporter.h ligne : 40
std::string transduce(symbol_t symbol) override;

Fichier : TransducerStaticWriter.h ligne : 28
std::string transduce(symbol_t symbol);

Tous les enfants de la classe Transducer on leur propre version de la fonction transduce, ce qui permet de toujours appeler cette fonction, mais différentes actions sont exécutés selon le type d'objet dont elle est appelée.

e. Un exemple de constructeur:
Fichier : TransducerCounter.cpp lignes : 7-10
TransducerCounter::TransducerCounter()
	: Transducer(), mCount{ 0 }
{
}
On initialise mCount à 0 et on créer la classe parent (Transducer).

f. Un exemple de destructeur:
Fichier : Transition.cpp lignes : 16-24
Transition::~Transition()
{
	delete mSymbolComparator;

	for (auto const & t : mTransducers)
	{
		delete t;
	}
}
Le destructeur va effacer la mémoire de la liste mTransducers.

g. Un exemple de constructeur de copie:
Fichier : Transducer.h ligne : 26
Transducer(const Transducer & transducer) = default;
Ici, en indiquant default, on laisse le compilateur gérée la construction des copies.

h. Un exemple d’opérateur d’assignation de copie:
Fichier : Transducer.h ligne : 28
Transducer& operator=(const Transducer & transducer) = default;
Ici, en indiquant default, on laisse le compilateur gérée l'assignation des copies.

i. Un exemple d’héritage;
Fichier : TransducerCounter.h ligne : 15
class TransducerCounter : public Transducer

Dans la déclaration de la classe TransducerCounter, celle-ci hérite du contenu de la classe parent Transducer dans sa section publique.

j. Un exemple de redéfinition de fonction de classe:
Fichier : TransducerCounter.h ligne : 35
std::string transduce(symbol_t symbol) override;

La fonction Transduce de la classe TransducerCounter redéfinit la fonction Transducer de classe parent Transducer.

k. Un exemple où la redéfinition d’une fonction de classe enfant appelle la fonction équivalente du parent:
Fichier : SymbolDistinctOne.cpp lignes : 10-13
bool SymbolDistinctOne::compare(symbol_t symbol) const
{
	return !SymbolMatchOne::compare(symbol);
}

La fonction compare() de la classe SymbolDistinctOne retourne l'inverse de la fonction compare() de la classe parent (SymbolMatchOne).

2. De façon concise et précise, veuillez expliquer dans vos mots les concepts suivants :
a. Pourquoi et comment vous faites la libération de la mémoire des objets alloués dynamiquement. Prenez le cas précis de la classe State qui libère les objets Transition.

Pour libérer la mémoire d'un objet et éviter les fuites de mémoire, on doit utiliser le mot clé "delete". Dans le cas des objets Transition, ils étaient contenu dans une liste, on a donc parcouru la liste au complet
 à l'aide d'une boucle for et on a utiliser delete à chaque objet.

b. Dans la section Fonctions obligatoires, il est stipulé que certaines fonctions requièrent des considérations supplémentaires. Expliquez pourquoi c’est le cas pour les classes identifiées. 
Aussi, expliquer la logique d’une solution pouvant résoudre ce problème et comment il serait possible de l’implémenter.

Les fonctions obligatoires requièrent des considérations supplémentaires car le constructeur de copie ainsi que les opérateurs d'assignation de copie doivent être "= delete".
Cette opération assure que les fonctions ne sont pas disponible. En les mettant "=delete", le compilateur ne laissera donc aucun autre objet utilisé les opérateurs d'assignation de copie et les constructeurs de copie.


3. Optionnellement, une section Recommandations pour indiquer toutes les coquilles que vous avez pu trouver dans cet énoncé et le code source ainsi que des suggestions (merci pour votre participation).
Exécuter le code avant de le donner aux élèves. (Free salt, do not take seriously) xP  //À changer idéalement.
