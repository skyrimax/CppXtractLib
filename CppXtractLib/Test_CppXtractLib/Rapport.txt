1.

	a) Exemple de masquage public

	Fichier: Reporter.h ligne 19

	public:

	b) Exemple de masquage protégé

	Fichier: TransducerCounter ligne 37

	protected:

	c) Exemple de masquage privé
	
	Fichier: Transition.h ligne 52

	private:

	d) Exemple de surcharge de fonction 
	
	Fichier: FileWriter.h lignes 32-33 (fonction "write")

	void write(symbol_t symbol) override;
	void write(const std::string & text) override;

	e) Exemple de constructeur
	
	Fichier: SymbolDinstinctAny.cpp lignes 5-8

	SymbolDistinctAny::SymbolDistinctAny(symbol_t symbol)
	: SymbolMatchAny(symbol)
	{
	
	}
	
	f) Exemple de destructeur

	Fichier: FST.cpp Lignes 18-26

	FST::~FST()
	{
       // utiliser une boucle for et l'instruction delete pour effacer
       // les états qui se trouvent dans mStates

		for (auto & state : mStates) {
			delete state;
		}
	}

	g) Exemple d'un constructeur de copie

	Fichier: SymbolMatchAll.h lignes 15-20

	
	SymbolMatchAll() = default;
	
	virtual ~SymbolMatchAll() = default;
	
	// Constructeur de copie
	SymbolMatchAll(const SymbolMatchAll & symbComp) = default;

	h) Exemple d'opération d'assignation de copie

	Fichier: SymbolMatchAny.h ligne 27

	// Opérateur d’assignation de copie par défaut disponible.
	SymbolMatchAny& operator=(const SymbolMatchAny & symbComp) = default;

	i) Exemple d'héritage

	Fichier SymbolMatchOne.h ligne 11

	class SymbolMatchOne : public SymbolComparator

	j) Exemple de redéfinition de fonction de classe

	Fichier: CppXtract.cpp lignes 40-42

	mTransducerStartBySpaceCounter = new TransducerCounter();
	mTransducerStartByLineCounter = new TransducerCounter();
	mTransducerStartByCharCounter = new TransducerCounter();

	k) Exemple de redéfinition de fonction de classe qui utilise la fonction parent

	Fichier SymbolMatchInRange.cpp lignes 39-42

	bool SymbolMatchInRange::compare(symbol_t symbol) const
	{
		return ((symbol >= mFirstSymbol) && (symbol <= mLastSymbol));
	}

2. Questions multiples:

	a) D'abord, on doit toujours libérer la mémoire des objects créé dynamiquement.
		C'est le principe même des fuites de mémoires.
		L'objet d'une transition qui a mené à l'état doit être supprimé, car de nouvelles transitions seront alors disponibles.

	b) Selon moi, il est important de spécifier qu'on ne peut pas créer de copie de ces objets, afin d'éviter de créer des doublons.
	Ces doublons pourraient mélanger la machine d'état. De plus, on cherche à n'avoir qu'une seule machine d'état qui gère les états et transitions.

3. Recommandations
	Très satisfait des commentaires déjà inclus.
	Beaucoup d'exemples sont sur le sites moodle.
	Avant d'entamer la production du laboratoire 1, ce serait bien de faire de plus petits exemples, en classe!
	Très bon travail de design, mais c'est très compliqué pour un débutant en C++.